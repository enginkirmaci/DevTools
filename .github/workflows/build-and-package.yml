name: Build and Package WinUI 3 App

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest

    env:
      Solution_Path: Tools.sln
      Project_Path: Tools\Tools.csproj
      Configuration: Release
      Platform: x64
      App_Packages_Directory: AppPackages

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 10.0.x

    - name: Restore NuGet Packages
      run: dotnet restore ${{ env.Solution_Path }}

    - name: Prepare Certificate
      env:
        CERTIFICATE_PASSWORD: ${{ secrets.APP_CERTIFICATE_PASSWORD }}
      shell: pwsh
      run: |
        # Use repository PFX if present (AppCertificate.pfx)
        $repoPfx = Join-Path $env:GITHUB_WORKSPACE "AppCertificate.pfx"
        if (Test-Path $repoPfx) {
          Write-Host "Using repository certificate: $repoPfx"
          # Validate the certificate if a password is provided
          try {
            $pwd = if ($env:CERTIFICATE_PASSWORD) { $env:CERTIFICATE_PASSWORD } else { $null }
            if ($pwd) {
              $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($repoPfx, $pwd, [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::MachineKeySet)
            } else {
              $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($repoPfx)
            }
            Write-Host "Loaded PFX: $($cert.Subject) - HasPrivateKey: $($cert.HasPrivateKey)"
          } catch {
            Write-Host "Failed to load repository PFX: $_"
            echo "CERT_PATH=" >> $env:GITHUB_ENV
            exit 1
          }

          echo "CERT_PATH=$repoPfx" >> $env:GITHUB_ENV
        } else {
          Write-Host "Repository certificate 'AppCertificate.pfx' not found. Package will not be signed."
          echo "CERT_PATH=" >> $env:GITHUB_ENV
        }

    - name: Build and Sign MSIX Package
      env:
        CERTIFICATE_PASSWORD: ${{ secrets.APP_CERTIFICATE_PASSWORD }}
      shell: pwsh
      run: |
        Write-Host "Building MSIX package with dotnet publish..."
        
        # Create the target AppPackages directory
        $targetDir = Join-Path $env:GITHUB_WORKSPACE $env:App_Packages_Directory
        New-Item -Path $targetDir -ItemType Directory -Force | Out-Null
        
        # Build dotnet publish command with signing if certificate is available
        $publishArgs = @(
          "publish", $env:Project_Path,
          "-c", $env:Configuration,
          "-r", "win-$env:Platform",
          "--self-contained", "true",
          "-p:GenerateAppxPackageOnBuild=true",
          "-p:AppxPackageDir=$targetDir\"
        )
        
        if ($env:CERT_PATH) {
          Write-Host "Certificate found. Enabling package signing..."
          $publishArgs += "-p:AppxPackageSigningEnabled=true"
          $publishArgs += "-p:PackageCertificateKeyFile=$env:CERT_PATH"
          if ($env:CERTIFICATE_PASSWORD) {
            $publishArgs += "-p:PackageCertificatePassword=$env:CERTIFICATE_PASSWORD"
          }
        } else {
          Write-Host "No certificate available. Package will not be signed."
          $publishArgs += "-p:AppxPackageSigningEnabled=false"
        }
        
        Write-Host "Running: dotnet $($publishArgs -join ' ')"
        & dotnet $publishArgs
        
        if ($LASTEXITCODE -ne 0) {
          Write-Host "dotnet publish failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
        
        Write-Host "Build completed. Locating MSIX package..."
        Write-Host "Searching for MSIX in: $targetDir"
        
        $msixFiles = Get-ChildItem -Path $targetDir -Filter "*.msix" -Recurse -ErrorAction SilentlyContinue
        
        if ($msixFiles.Count -eq 0) {
          Write-Host "ERROR: No MSIX package found. Listing AppPackages directory structure:"
          Get-ChildItem -Path $targetDir -Recurse -Force | ForEach-Object { Write-Host $_.FullName }
          
          # Also check the project bin directory as fallback
          $projectDir = Split-Path $env:Project_Path -Parent
          $binPath = Join-Path $projectDir "bin\$env:Platform\$env:Configuration"
          Write-Host "Checking fallback location: $binPath"
          if (Test-Path $binPath) {
            Get-ChildItem -Path $binPath -Recurse -Force | Where-Object { $_.Extension -eq ".msix" } | ForEach-Object { 
              Write-Host "Found MSIX at fallback location: $($_.FullName)"
              Copy-Item -Path $_.FullName -Destination $targetDir -Force
            }
          }
          
          # Re-check after fallback
          $msixFiles = Get-ChildItem -Path $targetDir -Filter "*.msix" -Recurse -ErrorAction SilentlyContinue
          if ($msixFiles.Count -eq 0) {
            exit 1
          }
        }
        
        Write-Host "Found MSIX packages:"
        foreach ($msix in $msixFiles) {
          Write-Host "  - $($msix.FullName)"
        }

    - name: Cleanup Certificate
      if: always()
      shell: pwsh
      run: |
        $certPath = Join-Path $env:GITHUB_WORKSPACE "Cert.pfx"
        if (Test-Path $certPath) {
          Remove-Item $certPath -Force
          Write-Host "Cleaned up certificate file"
        }

    - name: Upload MSIX Artifact
      uses: actions/upload-artifact@v4
      with:
        name: Tools-MSIX-win-x64
        path: ${{ env.App_Packages_Directory }}\**\*.msix
