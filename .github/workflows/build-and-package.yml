name: Build and Package WinUI 3 App

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest

    env:
      Solution_Path: Tools.sln
      Project_Path: Tools\Tools.csproj
      Configuration: Release
      Platform: x64
      App_Packages_Directory: AppPackages

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 10.0.x

    - name: Add MSBuild to PATH
      uses: microsoft/setup-msbuild@v2

    - name: Restore NuGet Packages
      run: msbuild $env:Solution_Path /t:Restore /p:Configuration=$env:Configuration

    # (Unpackaged publish and zip steps removed - build now only produces MSIX)

    # 2. Build MSIX Package
    - name: Create MSIX Package
      shell: pwsh
      run: |
        Write-Host "Building MSIX package..."
        
        # Create the target AppPackages directory
        $targetDir = Join-Path $env:GITHUB_WORKSPACE $env:App_Packages_Directory
        New-Item -Path $targetDir -ItemType Directory -Force | Out-Null
        
        # Use dotnet publish to create MSIX package
        dotnet publish $env:Project_Path `
          -c $env:Configuration `
          -r win-$env:Platform `
          --self-contained true `
          -p:GenerateAppxPackageOnBuild=true `
          -p:AppxPackageSigningEnabled=false `
          -p:AppxPackageDir="$targetDir\"
        
        if ($LASTEXITCODE -ne 0) {
          Write-Host "dotnet publish failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
        
        Write-Host "Build completed. Locating MSIX package..."
        Write-Host "Searching for MSIX in: $targetDir"
        
        $msixFiles = Get-ChildItem -Path $targetDir -Filter "*.msix" -Recurse -ErrorAction SilentlyContinue
        
        if ($msixFiles.Count -eq 0) {
          Write-Host "ERROR: No MSIX package found. Listing AppPackages directory structure:"
          Get-ChildItem -Path $targetDir -Recurse -Force | ForEach-Object { Write-Host $_.FullName }
          
          # Also check the project bin directory as fallback
          $projectDir = Split-Path $env:Project_Path -Parent
          $binPath = Join-Path $projectDir "bin\$env:Platform\$env:Configuration"
          Write-Host "Checking fallback location: $binPath"
          if (Test-Path $binPath) {
            Get-ChildItem -Path $binPath -Recurse -Force | Where-Object { $_.Extension -eq ".msix" } | ForEach-Object { 
              Write-Host "Found MSIX at fallback location: $($_.FullName)"
              Copy-Item -Path $_.FullName -Destination $targetDir -Force
            }
          }
          
          # Re-check after fallback
          $msixFiles = Get-ChildItem -Path $targetDir -Filter "*.msix" -Recurse -ErrorAction SilentlyContinue
          if ($msixFiles.Count -eq 0) {
            exit 1
          }
        }
        
        Write-Host "Found MSIX packages:"
        foreach ($msix in $msixFiles) {
          Write-Host "  - $($msix.FullName)"
        }

    # 3. Sign MSIX (Only if secrets are provided)
    - name: Decode and Sign MSIX
      env:
        CERTIFICATE_BASE64: ${{ secrets.APP_CERTIFICATE_BASE64 }}
        CERTIFICATE_PASSWORD: ${{ secrets.APP_CERTIFICATE_PASSWORD }}
      if: always()
      shell: pwsh
      run: |
        # Prefer repository PFX if present, otherwise decode secret
        $repoPfx = Join-Path $env:GITHUB_WORKSPACE "AppCertificate.pfx"
        if (Test-Path $repoPfx) {
          Write-Host "Using repository certificate: $repoPfx"
          $pfxPath = $repoPfx
        } else {
          if (-not $env:CERTIFICATE_BASE64) {
            Write-Host "No repository PFX and no CERTIFICATE_BASE64 provided. Cannot sign."
            exit 1
          }
          # Decode certificate and write to disk
          $certBuffer = [System.Convert]::FromBase64String("$env:CERTIFICATE_BASE64")
          $pfxPath = Join-Path $env:GITHUB_WORKSPACE "Cert.pfx"
          [System.IO.File]::WriteAllBytes($pfxPath, $certBuffer)
          Write-Host "Wrote PFX to: $pfxPath"
          Get-Item $pfxPath | Select-Object FullName,Length | ForEach-Object { Write-Host "PFX: $($_.FullName) Size: $($_.Length) bytes" }
        }

        # Prepare password (allow empty / no password)
        $pwd = $env:CERTIFICATE_PASSWORD
        if ($pwd -eq '') { $pwd = $null }

        # Try to load the PFX to get an early and clearer error if it's invalid
        try {
          if ($pwd) {
            $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($pfxPath, $pwd, [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::MachineKeySet)
          } else {
            $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($pfxPath)
          }
          Write-Host "Loaded PFX: $($cert.Subject) - HasPrivateKey: $($cert.HasPrivateKey)"
        } catch {
          Write-Host "Failed to load PFX: $_"
          if ($pfxPath -ne $repoPfx) { Remove-Item $pfxPath -ErrorAction SilentlyContinue }
          exit 1
        }

        $appxPackageDir = Join-Path $env:GITHUB_WORKSPACE $env:App_Packages_Directory
        $msixPath = Get-ChildItem -Path $appxPackageDir -Filter "*.msix" -Recurse | Select-Object -First 1

        if (-not $msixPath) {
          Write-Host "No MSIX package found in '$appxPackageDir'. Listing directory contents for debugging..."
          if (Test-Path $appxPackageDir) {
            Get-ChildItem -Path $appxPackageDir -Recurse -Force | ForEach-Object { Write-Host $_.FullName }
          } else {
            Write-Host "Folder '$appxPackageDir' does not exist."
          }
          Remove-Item $pfxPath -ErrorAction SilentlyContinue
          exit 1
        }

        # Locate signtool.exe (PATH first, then try Windows Kits folder dynamically)
        $signtool = (Get-Command signtool.exe -ErrorAction SilentlyContinue)?.Source
        if (-not $signtool) {
          $kits = Get-ChildItem "C:\\Program Files (x86)\\Windows Kits\\10\\bin" -Directory -ErrorAction SilentlyContinue | Sort-Object Name -Descending
          if ($kits -and $kits.Count -gt 0) {
            $signtoolCandidate = Join-Path $kits[0].FullName "x64\\signtool.exe"
            if (Test-Path $signtoolCandidate) { $signtool = $signtoolCandidate }
          }
        }
        if (-not $signtool -or -not (Test-Path $signtool)) {
          Write-Host "signtool not found. Searched PATH and Windows Kits. Please ensure signtool is available."
          Remove-Item $pfxPath -ErrorAction SilentlyContinue
          exit 1
        }

        Write-Host "Signing MSIX: $($msixPath.FullName) using: $signtool"
        & $signtool sign /v /f $pfxPath /p "$env:CERTIFICATE_PASSWORD" /fd sha256 /td sha256 "$($msixPath.FullName)"
        $exit = $LASTEXITCODE
        if ($exit -ne 0) {
          Write-Host "signtool failed with exit code $exit"
          Remove-Item $pfxPath -ErrorAction SilentlyContinue
          exit $exit
        }

        Write-Host "Sign completed successfully."
        Remove-Item $pfxPath -ErrorAction SilentlyContinue

    # (Unpackaged artifact upload removed - no unpackaged output produced)

    - name: Upload MSIX Artifact
      uses: actions/upload-artifact@v4
      with:
        name: Tools-MSIX-win-x64
        path: ${{ env.App_Packages_Directory }}\**\*.msix
