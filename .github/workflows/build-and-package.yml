name: Build and Package WinUI 3 App

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest

    env:
      Solution_Path: Tools.sln
      Project_Path: Tools\Tools.csproj
      Configuration: Release
      Platform: x64
      App_Packages_Directory: AppPackages

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 10.0.x

    - name: Add MSBuild to PATH
      uses: microsoft/setup-msbuild@v2

    - name: Restore NuGet Packages
      run: msbuild $env:Solution_Path /t:Restore /p:Configuration=$env:Configuration

    # 1. Build and Publish Unpackaged (Zip)
    - name: Publish Unpackaged
      run: |
        dotnet publish $env:Project_Path -c $env:Configuration -r win-$env:Platform --self-contained true -p:PublishReadyToRun=true -o ./publish

    - name: ZIP Unpackaged Output
      shell: pwsh
      run: |
        Compress-Archive -Path ./publish/* -DestinationPath ./Tools-Unpackaged-win-x64.zip

    # 2. Build MSIX Package
    - name: Create MSIX Package
      shell: pwsh
      run: |
        Write-Host "Building MSIX package..."
        
        dotnet publish $env:Project_Path `
          -c $env:Configuration `
          -r win-$env:Platform `
          -p:Platform=$env:Platform `
          -p:WindowsPackageType=MSIX `
          -p:UapAppxPackageBuildMode=SideloadOnly `
          -p:AppxBundle=Never `
          -p:AppxPackageSigningEnabled=false `
          -p:GenerateAppInstallerFile=false
        
        if ($LASTEXITCODE -ne 0) {
          Write-Host "dotnet publish failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
        
        Write-Host "Build completed. Locating MSIX package..."
        
        # MSIX is typically created in bin\{Platform}\{Configuration}\{TargetFramework}\{RuntimeIdentifier}\AppPackages
        $projectDir = Split-Path $env:Project_Path -Parent
        $searchPath = Join-Path $projectDir "bin"
        
        Write-Host "Searching for MSIX in: $searchPath"
        $msixFiles = Get-ChildItem -Path $searchPath -Filter "*.msix" -Recurse -ErrorAction SilentlyContinue
        
        if ($msixFiles.Count -eq 0) {
          Write-Host "ERROR: No MSIX package found. Listing bin directory structure:"
          Get-ChildItem -Path $searchPath -Recurse -Force | ForEach-Object { Write-Host $_.FullName }
          exit 1
        }
        
        # Create the target AppPackages directory
        $targetDir = Join-Path $env:GITHUB_WORKSPACE $env:App_Packages_Directory
        New-Item -Path $targetDir -ItemType Directory -Force | Out-Null
        
        Write-Host "Found MSIX packages:"
        foreach ($msix in $msixFiles) {
          Write-Host "  - $($msix.FullName)"
          $destPath = Join-Path $targetDir $msix.Name
          Copy-Item -Path $msix.FullName -Destination $destPath -Force
          Write-Host "Copied to: $destPath"
        }
        
        Write-Host "Contents of AppPackages directory:"
        Get-ChildItem -Path $targetDir -Recurse -Force | ForEach-Object { Write-Host $_.FullName }

    # 3. Sign MSIX (Only if secrets are provided)
    - name: Decode and Sign MSIX
      env:
        CERTIFICATE_BASE64: ${{ secrets.APP_CERTIFICATE_BASE64 }}
        CERTIFICATE_PASSWORD: ${{ secrets.APP_CERTIFICATE_PASSWORD }}
      if: env.CERTIFICATE_BASE64 != ''
      shell: pwsh
      run: |
        $certBuffer = [System.Convert]::FromBase64String("$env:CERTIFICATE_BASE64")
        $pfxPath = Join-Path $env:GITHUB_WORKSPACE "Cert.pfx"
        [System.IO.File]::WriteAllBytes($pfxPath, $certBuffer)

        $appxPackageDir = Join-Path $env:GITHUB_WORKSPACE $env:App_Packages_Directory
        $msixPath = Get-ChildItem -Path $appxPackageDir -Filter "*.msix" -Recurse | Select-Object -First 1

        if (-not $msixPath) {
          Write-Host "No MSIX package found in '$appxPackageDir'. Listing directory contents for debugging..."
          if (Test-Path $appxPackageDir) {
            Get-ChildItem -Path $appxPackageDir -Recurse -Force | ForEach-Object { Write-Host $_.FullName }
          } else {
            Write-Host "Folder '$appxPackageDir' does not exist."
          }
          Remove-Item $pfxPath -ErrorAction SilentlyContinue
          exit 1
        }

        # Locate signtool.exe if available on PATH, otherwise fall back to a known SDK path
        $signtool = (Get-Command signtool.exe -ErrorAction SilentlyContinue)?.Source
        if (-not $signtool) {
          $signtool = "C:\\Program Files (x86)\\Windows Kits\\10\\bin\\10.0.26100.0\\x64\\signtool.exe"
        }

        Write-Host "Signing MSIX: $($msixPath.FullName) using: $signtool"
        & $signtool sign /f $pfxPath /p "$env:CERTIFICATE_PASSWORD" /td sha256 /fd sha256 "$($msixPath.FullName)"

        Remove-Item $pfxPath

    - name: Upload Unpackaged Artifact
      uses: actions/upload-artifact@v4
      with:
        name: Tools-Unpackaged-win-x64
        path: Tools-Unpackaged-win-x64.zip

    - name: Upload MSIX Artifact
      uses: actions/upload-artifact@v4
      with:
        name: Tools-MSIX-win-x64
        path: ${{ env.App_Packages_Directory }}\**\*.msix
