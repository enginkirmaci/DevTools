name: Build and Package WinUI 3 App

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest

    env:
      Solution_Path: Tools.sln
      Project_Path: Tools\Tools.csproj
      Configuration: Release
      Platform: x64
      App_Packages_Directory: AppPackages

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 10.0.x

    - name: Add MSBuild to PATH
      uses: microsoft/setup-msbuild@v2

    - name: Restore NuGet Packages
      run: msbuild $env:Solution_Path /t:Restore /p:Configuration=$env:Configuration

    # 1. Build and Publish Unpackaged (Zip)
    - name: Publish Unpackaged
      run: |
        dotnet publish $env:Project_Path -c $env:Configuration -r win-$env:Platform --self-contained true -p:PublishReadyToRun=true -o ./publish

    - name: ZIP Unpackaged Output
      shell: pwsh
      run: |
        Compress-Archive -Path ./publish/* -DestinationPath ./Tools-Unpackaged-win-x64.zip

    # 2. Build MSIX Package
    - name: Create MSIX Package
      run: |
        msbuild $env:Project_Path `
          /p:Configuration=$env:Configuration `
          /p:Platform=$env:Platform `
          /p:WindowsPackageType=MSIX `
          /p:UapAppxPackageBuildMode=SideloadOnly `
          /p:AppxBundle=Never `
          /p:GenerateAppxPackageOnBuild=true `
          /p:AppxPackageDir="$env:App_Packages_Directory" `
          /p:AppxPackageSigningEnabled=false

    # 3. Sign MSIX (Only if secrets are provided)
    - name: Decode and Sign MSIX
      env:
        CERTIFICATE_BASE64: ${{ secrets.APP_CERTIFICATE_BASE64 }}
        CERTIFICATE_PASSWORD: ${{ secrets.APP_CERTIFICATE_PASSWORD }}
      if: env.CERTIFICATE_BASE64 != ''
      shell: pwsh
      run: |
        $certBuffer = [System.Convert]::FromBase64String("$env:CERTIFICATE_BASE64")
        $pfxPath = Join-Path $env:GITHUB_WORKSPACE "Cert.pfx"
        [System.IO.File]::WriteAllBytes($pfxPath, $certBuffer)

        $msixPath = Get-ChildItem -Path $env:App_Packages_Directory -Filter "*.msix" -Recurse | Select-Object -First 1

        if (-not $msixPath) {
          Write-Host "No MSIX package found in '$env:App_Packages_Directory'. Listing directory contents for debugging..."
          if (Test-Path $env:App_Packages_Directory) {
            Get-ChildItem -Path $env:App_Packages_Directory -Recurse -Force | ForEach-Object { Write-Host $_.FullName }
          } else {
            Write-Host "Folder '$env:App_Packages_Directory' does not exist."
          }
          Remove-Item $pfxPath -ErrorAction SilentlyContinue
          exit 1
        }

        # Locate signtool.exe if available on PATH, otherwise fall back to a known SDK path
        $signtool = (Get-Command signtool.exe -ErrorAction SilentlyContinue)?.Source
        if (-not $signtool) {
          $signtool = "C:\\Program Files (x86)\\Windows Kits\\10\\bin\\10.0.26100.0\\x64\\signtool.exe"
        }

        Write-Host "Signing MSIX: $($msixPath.FullName) using: $signtool"
        & $signtool sign /f $pfxPath /p "$env:CERTIFICATE_PASSWORD" /td sha256 /fd sha256 "$($msixPath.FullName)"

        Remove-Item $pfxPath

    - name: Upload Unpackaged Artifact
      uses: actions/upload-artifact@v4
      with:
        name: Tools-Unpackaged-win-x64
        path: Tools-Unpackaged-win-x64.zip

    - name: Upload MSIX Artifact
      uses: actions/upload-artifact@v4
      with:
        name: Tools-MSIX-win-x64
        path: ${{ env.App_Packages_Directory }}\**\*.msix
